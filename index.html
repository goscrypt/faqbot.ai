<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Offline FAQ Assistant</title>
<style>
  :root { color-scheme: light dark; --bg:#0b0c0f; --fg:#e6e8eb; --muted:#9aa3ab; --accent:#4f46e5; --card:#151821; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin:0; background:var(--bg); color:var(--fg); }
  header { padding:16px 20px; border-bottom:1px solid #1f2430; display:flex; align-items:center; gap:12px; }
  header h1 { font-size:18px; margin:0; }
  main { max-width:980px; margin:0 auto; padding:20px; display:grid; gap:16px; }
  section { background:var(--card); border:1px solid #1f2430; border-radius:12px; padding:16px; }
  h2 { margin:0 0 10px; font-size:16px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; }
  input[type="file"], button, select, input[type="text"], textarea {
    background:#0e1118; color:var(--fg); border:1px solid #2a3140; border-radius:10px; padding:10px 12px; font-size:14px;
  }
  button { cursor:pointer; background:linear-gradient(180deg, #5b54f6, #4038d9); border:none; }
  button.secondary { background:#0e1118; border:1px solid #2a3140; }
  .pill { font-size:12px; color:var(--muted); }
  .grid { display:grid; gap:8px; }
  .cols-2 { grid-template-columns: 1fr 1fr; }
  .result { white-space:pre-wrap; line-height:1.5; }
  .badge { display:inline-block; padding:2px 8px; border:1px solid #2a3140; border-radius:999px; font-size:12px; color:var(--muted); }
  .table { width:100%; border-collapse:collapse; }
  .table th, .table td { text-align:left; padding:8px; border-bottom:1px solid #212737; font-size:13px; vertical-align:top; }
  .small { font-size:12px; color:var(--muted); }
  .ok { color:#38bdf8; }
  .warn { color:#f59e0b; }
  .err { color:#f97373; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .hidden { display:none; }
</style>
</head>
<body>
<header>
  <svg width="22" height="22" viewBox="0 0 24 24" fill="#4f46e5" xmlns="http://www.w3.org/2000/svg"><path d="M12 2l3 7h7l-5.5 4 2.5 7-7-4.5L5 20l2.5-7L2 9h7l3-7z"/></svg>
  <h1>Offline FAQ Assistant</h1>
  <span id="status" class="pill">Loading…</span>
</header>

<main>
  <section>
    <h2>Load training document</h2>
    <div class="row">
      <input type="file" id="file" accept=".txt,.csv" />
      <select id="format">
        <option value="auto" selected>Auto-detect format</option>
        <option value="txt">TXT (Q: / A: pairs)</option>
        <option value="csv">CSV (headers: question,answer)</option>
      </select>
      <button id="clear">Clear index</button>
      <span id="fileInfo" class="pill"></span>
    </div>
    <p class="small">Accepted formats:
      <span class="badge">TXT with lines like "Q: ..." and "A: ..."</span>
      <span class="badge">CSV with "question,answer" columns</span>
    </p>
  </section>

  <section>
    <h2>Ask a question</h2>
    <div class="row">
      <input id="query" type="text" placeholder="e.g., How do I handle a customer upset about delays?" style="flex:1"/>
      <button id="ask">Ask</button>
    </div>
    <p class="small">Tip: The assistant finds the closest FAQ entries and rewrites an improved, clearer response.</p>
  </section>

  <section>
    <h2>Result</h2>
    <div class="grid cols-2">
      <div>
        <div class="badge">Improved response</div>
        <div id="improved" class="result"></div>
      </div>
      <div>
        <div class="badge">Matched references</div>
        <table class="table" id="matches">
          <thead><tr><th>#</th><th>Question</th><th>Answer</th><th>Similarity</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="grid" style="margin-top:10px">
      <div class="badge">Why this answer</div>
      <div id="why" class="small"></div>
    </div>
  </section>

  <section>
    <h2>Model and offline status</h2>
    <div id="modelStatus" class="small"></div>
  </section>
</main>

<script type="module">
// Lightweight, in-browser AI using transformers.js
// Pipelines:
//  - feature-extraction: Xenova/all-MiniLM-L6-v2 (semantic embeddings)
//  - text2text-generation: Xenova/t5-small (clarity rewrite)

const el = (id) => document.getElementById(id);
const state = {
  faqs: [],          // {question, answer, text}
  embeddings: [],    // Float32Array per faq
  fe: null,          // feature-extraction pipeline
  rewriter: null,    // text2text-generation pipeline
};

function setStatus(msg, cls='') {
  const s = el('status');
  s.textContent = msg;
  s.className = 'pill ' + cls;
}
function setModelStatus(msg) {
  el('modelStatus').textContent = msg;
}

function normalize(vec) {
  let sum = 0;
  for (let i = 0; i < vec.length; i++) sum += vec[i] * vec[i];
  const norm = Math.sqrt(sum) || 1;
  const out = new Float32Array(vec.length);
  for (let i = 0; i < vec.length; i++) out[i] = vec[i] / norm;
  return out;
}
function cosine(a, b) {
  let s = 0;
  for (let i = 0; i < a.length; i++) s += a[i] * b[i];
  return s;
}

async function loadModels() {
  setStatus('Loading models…');
  setModelStatus('Initializing transformers.js (this may take a moment the first time)…');

  // dynamic import so the HTML remains one file
  const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.1');

  // Feature extraction (embeddings)
  state.fe = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
  setModelStatus('Embeddings ready (all-MiniLM-L6-v2). Preparing rewrite model…');

  // Text-to-text generation (rewriter)
  // t5-small is compact; we’ll steer it with a clear instruction prompt.
  state.rewriter = await pipeline('text2text-generation', 'Xenova/t5-small');

  setStatus('Ready', 'ok');
  setModelStatus('Models loaded. This page and model files are cached for offline use after first load.');
}

function detectFormat(text) {
  if (el('format').value !== 'auto') return el('format').value;
  const hasCSVComma = /[,;]/.test(text.split('\n')[0]) && /question|answer/i.test(text);
  if (hasCSVComma) return 'csv';
  if (/^Q:\s*/mi.test(text) && /^A:\s*/mi.test(text)) return 'txt';
  return 'txt';
}

function parseTXT(text) {
  // Supports blocks like:
  // Q: ...
  // A: ...
  const lines = text.split(/\r?\n/);
  const faqs = [];
  let q = '', a = '';
  for (const line of lines) {
    if (line.trim().toLowerCase().startsWith('q:')) {
      if (q || a) { // flush previous
        if (q && a) faqs.push({ question: q.trim(), answer: a.trim(), text: (q + ' ' + a).trim() });
        q = ''; a = '';
      }
      q = line.replace(/^q:\s*/i, '');
    } else if (line.trim().toLowerCase().startsWith('a:')) {
      a = (a ? a + ' ' : '') + line.replace(/^a:\s*/i, '');
    } else {
      // continuation line; attach to last seen (prefer answer)
      if (a) a += ' ' + line.trim();
      else if (q) q += ' ' + line.trim();
    }
  }
  if (q && a) faqs.push({ question: q.trim(), answer: a.trim(), text: (q + ' ' + a).trim() });
  return faqs;
}

function parseCSV(text) {
  // Minimal CSV parser for two columns: question,answer (header row required)
  const rows = text.split(/\r?\n/).filter(Boolean);
  if (rows.length === 0) return [];
  const header = rows[0].split(',').map(h => h.trim().toLowerCase());
  const qIdx = header.findIndex(h => h.includes('question'));
  const aIdx = header.findIndex(h => h.includes('answer'));
  const faqs = [];
  for (let i = 1; i < rows.length; i++) {
    const cols = rows[i].split(',');
    const q = (cols[qIdx] || '').trim();
    const a = (cols[aIdx] || '').trim();
    if (q && a) faqs.push({ question: q, answer: a, text: `${q} ${a}` });
  }
  return faqs;
}

async function embed(text) {
  const out = await state.fe(text, { pooling: 'mean', normalize: true });
  // transformers.js returns a Tensor-like; .data is a TypedArray
  return new Float32Array(out.data);
}

async function buildIndex(faqs) {
  state.faqs = faqs;
  state.embeddings = [];
  for (const item of faqs) {
    const vec = await embed(item.text);
    state.embeddings.push(vec);
  }
}

function topK(queryVec, k = 3) {
  const scores = state.embeddings.map((vec, idx) => ({ idx, score: cosine(queryVec, vec) }));
  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, Math.min(k, scores.length));
}

function renderMatches(matches) {
  const tbody = document.querySelector('#matches tbody');
  tbody.innerHTML = '';
  matches.forEach((m, i) => {
    const item = state.faqs[m.idx];
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${i + 1}</td>
      <td class="mono">${escapeHTML(item.question).slice(0,180)}</td>
      <td class="mono">${escapeHTML(item.answer).slice(0,220)}</td>
      <td class="small">${m.score.toFixed(3)}</td>
    `;
    tbody.appendChild(tr);
  });
}

function escapeHTML(s) {
  return s.replace(/[&<>'"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;',"'":'&#39;','"':'&quot;'}[c]));
}

function synthPrompt(userQuery, contexts) {
  // Instruction steering for T5-small (kept concise)
  const guide = [
    'Improve clarity and completeness.',
    'Answer the user question directly.',
    'Use 3-6 sentences. If steps help, use brief numbered steps.',
    'Keep tone friendly and professional.',
    'If policy or escalation applies, include it tersely.',
    'Add one short example when useful.',
  ].join(' ');
  const ctx = contexts.map((c, i) => `Ref${i+1} Q: ${c.question}\nRef${i+1} A: ${c.answer}`).join('\n');
  // T5 expects a "task: input" style; we’ll use a neutral "paraphrase/rewrite" frame.
  return `paraphrase: ${guide}\nUser: ${userQuery}\n${ctx}`;
}

async function rewriteAnswer(userQuery, contexts) {
  // Build a candidate base by stitching the top answers; the rewriter will make it clearer
  const stitched = contexts.map((c, i) => `• ${c.answer}`).join('\n');
  const prompt = synthPrompt(userQuery, contexts) + `\nCandidate:\n${stitched}\nOutput:`;
  try {
    const out = await state.rewriter(prompt, {
      max_new_tokens: 160,
      temperature: 0.4,
      top_p: 0.9,
      repetition_penalty: 1.05,
    });
    const text = (Array.isArray(out) ? out[0].generated_text : out.generated_text) || '';
    return text.trim();
  } catch (e) {
    // Fallback: structured rewrite without the model
    return heuristicRewrite(userQuery, contexts);
  }
}

function heuristicRewrite(userQuery, contexts) {
  const points = [];
  const merged = contexts.map(c => c.answer).join(' ');
  // Basic heuristics
  if (!/apolog/i.test(merged) && /delay|late|wait/i.test(userQuery)) {
    points.push('Start with a brief apology and acknowledge the delay.');
  }
  if (!/step|1\.|2\./i.test(merged)) {
    points.push('Outline practical steps the employee should follow.');
  }
  if (!/escalate|supervisor|ticket/i.test(merged)) {
    points.push('Offer an escalation path if the first fix is not possible.');
  }
  const example = `Example: “I understand the delay is frustrating. Here’s what I can do right now… If needed, I can escalate this to our specialist.”`;
  return [
    `Here’s a clearer response tailored to your question:`,
    `1. Acknowledge the concern and set expectations.`,
    `2. Provide the most relevant solution based on our guidelines.`,
    `3. Offer alternatives or escalation if needed.`,
    example
  ].join('\n');
}

async function handleAsk() {
  const q = el('query').value.trim();
  if (!q) return;
  if (!state.fe || state.embeddings.length === 0) {
    el('improved').textContent = 'Load a training document first.';
    return;
  }
  setStatus('Thinking…');
  const qVec = await embed(q);
  const matches = topK(qVec, 3);
  renderMatches(matches);
  const contexts = matches.map(m => state.faqs[m.idx]);
  const improved = await rewriteAnswer(q, contexts);

  el('improved').textContent = improved || '(No suggestion generated)';
  el('why').textContent = `Matched ${contexts.length} reference(s) using semantic similarity (MiniLM). The response was rewritten for clarity and completeness using a compact transformer model.`;
  setStatus('Ready', 'ok');
}

// File handling
el('file').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const txt = await file.text();
  const fmt = detectFormat(txt);
  let faqs = [];
  try {
    faqs = fmt === 'csv' ? parseCSV(txt) : parseTXT(txt);
  } catch {
    faqs = parseTXT(txt);
  }
  if (faqs.length === 0) {
    el('fileInfo').textContent = 'No Q/A pairs found.';
    el('file').value = '';
    return;
  }
  el('fileInfo').textContent = `Loaded ${faqs.length} Q/A pairs (${fmt.toUpperCase()}). Building index…`;
  setStatus('Indexing…');
  await buildIndex(faqs);
  setStatus('Ready', 'ok');
  el('fileInfo').textContent = `Indexed ${faqs.length} entries.`;
});

el('ask').addEventListener('click', handleAsk);
el('query').addEventListener('keydown', (e) => { if (e.key === 'Enter') handleAsk(); });
el('clear').addEventListener('click', () => {
  state.faqs = []; state.embeddings = [];
  document.querySelector('#matches tbody').innerHTML = '';
  el('improved').textContent = '';
  el('why').textContent = '';
  el('file').value = '';
  el('fileInfo').textContent = 'Cleared.';
});

// Boot
loadModels().catch(err => {
  setStatus('Model load failed', 'err');
  setModelStatus('Could not load models. You can still use heuristic mode (semantic search only).');
});

// Offline caching via Service Worker (inline)
if ('serviceWorker' in navigator) {
  const swCode = `
    const CACHE = 'faq-assistant-cache-v1';
    self.addEventListener('install', (e) => {
      self.skipWaiting();
      e.waitUntil(caches.open(CACHE).then(c => c.addAll(['./'])).catch(()=>{}));
    });
    self.addEventListener('activate', (e) => {
      e.waitUntil(self.clients.claim());
    });
    self.addEventListener('fetch', (event) => {
      const req = event.request;
      // Cache-first for same-origin; network-first for CDN with cache fallback
      if (new URL(req.url).origin === self.location.origin) {
        event.respondWith(caches.match(req).then(res => res || fetch(req).then(resp => {
          const copy = resp.clone();
          caches.open(CACHE).then(c => c.put(req, copy));
          return resp;
        })));
      } else {
        event.respondWith(fetch(req).then(resp => {
          const copy = resp.clone();
          caches.open(CACHE).then(c => c.put(req, copy));
          return resp;
        }).catch(() => caches.match(req)));
      }
    });
  `;
  const blob = new Blob([swCode], { type: 'text/javascript' });
  const url = URL.createObjectURL(blob);
  navigator.serviceWorker.register(url).catch(()=>{});
}
</script>
</body>
</html>
