<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, viewport-fit=cover"
  />
  <title>Offline FAQ Assistant</title>

  <!-- .docx support (browser-only) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"
        integrity="sha512-J3ofce2fC+odxSdGxyHQ9fro/clUWzrG5rpnv0xYaCgvaofYZxJSNxvnIY+hYqwd2zc/pByyzfHySGumKld9xg=="
        crossorigin="anonymous"></script>

  <style>
    :root { color-scheme: light dark; --bg:#0b0c0f; --fg:#e6e8eb; --muted:#9aa3ab; --accent:#4f46e5; --card:#151821; --border:#1f2430; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:16px 20px; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:12px; }
    h1 { margin:0; font-size:18px; }
    main { max-width:1024px; margin:0 auto; padding:20px; display:grid; gap:16px; }
    section { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; }
    h2 { margin:0 0 10px; font-size:16px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    input[type="file"], button, select, input[type="text"] {
      background:#0e1118; color:var(--fg); border:1px solid #2a3140; border-radius:10px; padding:10px 12px; font-size:14px;
    }
    button { cursor:pointer; background:linear-gradient(180deg, #5b54f6, #4038d9); border:none; }
    button.secondary { background:#0e1118; border:1px solid #2a3140; }
    .pill { font-size:12px; color:var(--muted); }
    .badge { display:inline-block; padding:2px 8px; border:1px solid #2a3140; border-radius:999px; font-size:12px; color:var(--muted); }
    .result { white-space:pre-wrap; line-height:1.5; }
    .table { width:100%; border-collapse:collapse; }
    .table th, .table td { text-align:left; padding:8px; border-bottom:1px solid #212737; font-size:13px; vertical-align:top; }
    .small { font-size:12px; color:var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <header>
    <h1>Offline FAQ Assistant</h1>
    <span id="status" class="pill">Loading‚Ä¶</span>
  </header>

  <main>
    <section>
      <h2>Load training document</h2>
      <div class="row">
        <input type="file" id="fileInput" accept=".txt,.csv,.docx" />
        <select id="format">
          <option value="auto" selected>Auto-detect format</option>
          <option value="txt">TXT (Q: / A: pairs)</option>
          <option value="csv">CSV (question,answer)</option>
        </select>
        <button id="clear" class="secondary">Clear index</button>
        <span id="fileInfo" class="pill"></span>
      </div>
      <p class="small">
        Formats: <span class="badge">TXT with lines ‚ÄúQ: ‚Ä¶‚Äù, ‚ÄúA: ‚Ä¶‚Äù (multi-line allowed)</span>
        <span class="badge">CSV headers: ‚Äúquestion,answer‚Äù</span>
        <span class="badge">DOCX: Q/A content extracted as text</span>
      </p>
    </section>

    <section>
      <h2>Ask a question</h2>
      <div class="row" style="gap:10px">
        <input id="query" type="text" placeholder="e.g., How do I handle a customer upset about delays?" style="flex:1"/>
        <button id="ask">Ask</button>
      </div>
      <p class="small">The assistant finds the closest FAQ entries semantically and rewrites a clearer, complete response.</p>
    </section>

    <section>
      <h2>Result</h2>
      <div class="badge">Improved response</div>
      <div id="improved" class="result"></div>
      <div style="height:8px"></div>
      <div class="badge">Matched references</div>
      <table class="table" id="matches">
        <thead><tr><th>#</th><th>Question</th><th>Answer</th><th>Similarity</th></tr></thead>
        <tbody></tbody>
      </table>
      <div style="height:8px"></div>
      <div class="badge">Why this answer</div>
      <div id="why" class="small"></div>
    </section>

    <section>
      <h2>Model status</h2>
      <div id="modelStatus" class="small"></div>
    </section>
  </main>

  <script type="module">
    // Ensure DOM exists before querying
    window.addEventListener('DOMContentLoaded', () => {
      const el = (id) => document.getElementById(id);

      const state = {
        faqs: [],          // {question, answer, text}
        embeddings: [],    // Float32Array per faq
        fe: null,          // feature-extraction pipeline (MiniLM)
        rewriter: null,    // text2text-generation pipeline (T5-small)
      };

      function setStatus(msg) { el('status').textContent = msg; }
      function setModelStatus(msg) { el('modelStatus').textContent = msg; }
      function escapeHTML(s) { return s.replace(/[&<>'"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;',"'":'&#39;','"':'&quot;'}[c])); }

      // CSV parser that respects basic quoted fields with commas
      function parseCSV(text) {
        const rows = [];
        let row = [], cur = '', inQuotes = false;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i], next = text[i+1];
          if (ch === '"' && !inQuotes) { inQuotes = true; continue; }
          if (ch === '"' && inQuotes) {
            if (next === '"') { cur += '"'; i++; continue; }
            inQuotes = false; continue;
          }
          if (ch === ',' && !inQuotes) { row.push(cur); cur = ''; continue; }
          if ((ch === '\n' || ch === '\r') && !inQuotes) {
            if (cur.length || row.length) { row.push(cur); rows.push(row); row = []; cur=''; }
            continue;
          }
          cur += ch;
        }
        if (cur.length || row.length) { row.push(cur); rows.push(row); }

        if (rows.length === 0) return [];
        const header = rows[0].map(h => h.trim().toLowerCase());
        const qIdx = header.findIndex(h => h.includes('question'));
        const aIdx = header.findIndex(h => h.includes('answer'));
        if (qIdx === -1 || aIdx === -1) return [];
        const faqs = [];
        for (let i = 1; i < rows.length; i++) {
          const cols = rows[i];
          const q = (cols[qIdx] || '').trim();
          const a = (cols[aIdx] || '').trim();
          if (q && a) faqs.push({ question: q, answer: a, text: `${q} ${a}` });
        }
        return faqs;
      }

     function parseTXT(text) {
  // your existing code
}

function parseCSV(text) {
  // your existing code
}

// üî• New chunking function for non-FAQ documents
function chunkText(text, chunkSize = 500) {
  const sentences = text.split(/(?<=[.?!])\s+/);
  const chunks = [];
  let current = '';

  for (const sentence of sentences) {
    if ((current + sentence).length < chunkSize) {
      current += sentence + ' ';
    } else {
      chunks.push(current.trim());
      current = sentence + ' ';
    }
  }
  if (current.trim()) chunks.push(current.trim());

  return chunks.map((text, i) => ({
    question: `Chunk ${i + 1}`,
    answer: text,
    text: text
  }));
}

      function detectFormat(text) {
        if (el('format').value !== 'auto') return el('format').value;
        const header = text.split(/\r?\n/)[0] || '';
        if (/question/i.test(text) && /answer/i.test(text) && header.includes(',')) return 'csv';
        if (/^q:\s*/mi.test(text) && /^a:\s*/mi.test(text)) return 'txt';
        return 'txt';
      }

      async function loadModels() {
        try {
          setStatus('Loading models‚Ä¶');
          setModelStatus('Initializing transformers.js‚Ä¶');
          const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.1');

          state.fe = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
          setModelStatus('Embeddings ready (all-MiniLM-L6-v2). Loading rewrite model‚Ä¶');

          state.rewriter = await pipeline('text2text-generation', 'Xenova/t5-small');
          setStatus('Ready');
          setModelStatus('Models loaded. After this first load, your browser caches them for offline use.');
        } catch (err) {
          console.error(err);
          setStatus('Semantic-only mode');
          setModelStatus('Failed to load one or more models. Semantic search may work if embeddings load; rewriting will fall back to heuristics.');
        }
      }

      async function embed(text) {
        if (!state.fe) throw new Error('Embedding model not loaded');
        const out = await state.fe(text, { pooling: 'mean', normalize: true });
        return new Float32Array(out.data);
      }

      function cosine(a, b) {
        let s = 0;
        for (let i = 0; i < a.length; i++) s += a[i] * b[i];
        return s;
      }

      async function buildIndex(faqs) {
        state.faqs = faqs;
        state.embeddings = [];
        for (const item of faqs) {
          const vec = await embed(item.text);
          state.embeddings.push(vec);
        }
      }

      function topK(queryVec, k = 3) {
        const scores = state.embeddings.map((vec, idx) => ({ idx, score: cosine(queryVec, vec) }));
        scores.sort((a, b) => b.score - a.score);
        return scores.slice(0, Math.min(k, scores.length));
      }

      function renderMatches(matches) {
        const tbody = document.querySelector('#matches tbody');
        tbody.innerHTML = '';
        matches.forEach((m, i) => {
          const item = state.faqs[m.idx];
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${i + 1}</td>
            <td class="mono">${escapeHTML(item.question).slice(0, 180)}</td>
            <td class="mono">${escapeHTML(item.answer).slice(0, 220)}</td>
            <td class="small">${m.score.toFixed(3)}</td>
          `;
          tbody.appendChild(tr);
        });
      }

      function synthPrompt(userQuery, contexts) {
        const guide = [
          'Improve clarity and completeness.',
          'Answer the user question directly.',
          'Use 3-6 sentences. Include brief numbered steps when helpful.',
          'Keep tone friendly and professional.',
          'Add one short example when useful.'
        ].join(' ');
        const ctx = contexts.map((c, i) => `Ref${i+1} Q: ${c.question}\nRef${i+1} A: ${c.answer}`).join('\n');
        return `paraphrase: ${guide}\nUser: ${userQuery}\n${ctx}`;
      }

      function heuristicRewrite(userQuery, contexts) {
        const merged = contexts.map(c => c.answer).join(' ');
        const lines = [];
        if (/delay|late|wait/i.test(userQuery) && !/apolog/i.test(merged)) {
          lines.push('Start with a brief apology and acknowledge the delay.');
        }
        if (!/step|1\.|2\./i.test(merged)) {
          lines.push('Outline practical steps the employee should follow.');
        }
        if (!/escalate|supervisor|ticket|specialist/i.test(merged)) {
          lines.push('Offer an escalation path if the first fix is not possible.');
        }
        const example = 'Example: ‚ÄúI understand the delay is frustrating. Here‚Äôs what I can do right now‚Ä¶ If needed, I can escalate this to our specialist.‚Äù';
        return [
          'Here‚Äôs a clearer response tailored to your question:',
          '1. Acknowledge the concern and set expectations.',
          '2. Provide the most relevant solution based on our guidelines.',
          '3. Offer alternatives or escalation if needed.',
          example,
          lines.length ? ('Notes: ' + lines.join(' ')) : ''
        ].filter(Boolean).join('\n');
      }

      async function rewriteAnswer(userQuery, contexts) {
        if (!state.rewriter) {
          return heuristicRewrite(userQuery, contexts);
        }
        const stitched = contexts.map((c) => `‚Ä¢ ${c.answer}`).join('\n');
        const prompt = synthPrompt(userQuery, contexts) + `\nCandidate:\n${stitched}\nOutput:`;
        try {
          const out = await state.rewriter(prompt, {
            max_new_tokens: 160,
            temperature: 0.4,
            top_p: 0.9,
            repetition_penalty: 1.05,
          });
          const text = (Array.isArray(out) ? out[0].generated_text : out.generated_text) || '';
          return text.trim();
        } catch (e) {
          console.warn('Rewriter failed, using heuristic.', e);
          return heuristicRewrite(userQuery, contexts);
        }
      }

      async function handleAsk() {
        const q = el('query').value.trim();
        if (!q) return;
        if (!state.faqs.length) {
          el('improved').textContent = 'Load a training document first.';
          return;
        }
        setStatus('Thinking‚Ä¶');
        try {
          const qVec = await embed(q);
          const matches = topK(qVec, 3);
          renderMatches(matches);
          const contexts = matches.map(m => state.faqs[m.idx]);
          const improved = await rewriteAnswer(q, contexts);
          el('improved').textContent = improved || '(No suggestion generated)';
          el('why').textContent = 'Matched references via semantic similarity (MiniLM). Response rewritten for clarity and completeness.';
          setStatus('Ready');
        } catch (err) {
          console.error(err);
          el('improved').textContent = 'Model not ready. Try reloading the page or check your network.';
          setStatus('Model error');
        }
      }

      // File handling
      el('fileInput').addEventListener('change', async (e) => {
const file = e.target.files[0];
if (!file) return;

setStatus('Reading‚Ä¶');

let rawText = '';
if (file.name.endsWith('.docx')) {
  const reader = new FileReader();
  rawText = await new Promise((resolve, reject) => {
    reader.onload = (event) => {
      mammoth.convertToHtml({ arrayBuffer: event.target.result })
        .then((res) => resolve(res.value.replace(/<[^>]+>/g, '\n')))
        .catch(reject);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
} else {
  rawText = await file.text();
}

const cleaned = rawText.replace(/\s+/g, ' ').trim();
const faqs = chunkText(cleaned);

if (!faqs.length) {
  el('fileInfo').textContent = 'No usable content found.';
  setStatus('Ready');
  return;
}

el('fileInfo').textContent = `Loaded ${faqs.length} semantic chunks. Building index‚Ä¶`;
setStatus('Indexing‚Ä¶');
await buildIndex(faqs);
setStatus('Ready');

        }
      });

      el('ask').addEventListener('click', handleAsk);
      el('query').addEventListener('keydown', (e) => { if (e.key === 'Enter') handleAsk(); });
      el('clear').addEventListener('click', () => {
        state.faqs = [];
        state.embeddings = [];
        document.querySelector('#matches tbody').innerHTML = '';
        el('improved').textContent = '';
        el('why').textContent = '';
        el('fileInfo').textContent = 'Cleared.';
      });

      // Kick off model load after DOM is ready
      loadModels();
    });
  </script>
</body>
</html>
